/*
 *    This program is free software; you can redistribute it and/or modify
 *    it under the terms of the GNU General Public License as published by
 *    the Free Software Foundation; either version 2 of the License, or
 *    (at your option) any later version.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 *
 *    You should have received a copy of the GNU General Public License
 *    along with this program; if not, write to the Free Software
 *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

/*
 *    MultiTUBEClusterer.java
 *    Copyright (C) 2009 Gabi Schmidberger
 */
package weka.clusterers;

import java.util.Enumeration;
import java.util.Random;
import java.util.Vector;

import weka.core.Capabilities;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.OptionHandler;
import weka.core.RevisionUtils;
import weka.core.Utils;
import weka.core.WeightedInstancesHandler;
import weka.core.Capabilities.Capability;
import weka.core.Debug.DBO;
import weka.estimators.EstimatorUtils;
import weka.estimators.MultiBin;
import weka.estimators.MultiBinningEstimator;
import weka.estimators.MultiBinningUtils;
import weka.estimators.MultiDifference;
import weka.estimators.MultiEstimator;
import weka.estimators.MultiTUBE;
import weka.estimators.MultiBinningUtils.BinPath;
import weka.estimators.MultiBinningUtils.Tree;
import weka.filters.unsupervised.attribute.ReplaceMissingValues;

/**
<!-- globalinfo-start -->
 * Subspace clusterer. Clusteres the bins generated by Multi-TUBE discretization.
<!-- globalinfo-leftEnd -->
 *
<!-- options-start -->
<!-- options-leftEnd -->
 *
 * @author Gabi Schmidberger (gabi dot schmidberger at gmail dot com)
 * @version $Revision: 1.0 $
 */
public class MultiTUBEClusterer 
extends RandomizableClusterer
implements WeightedInstancesHandler, OptionHandler {

 
/**
	 * 
	 */
	private static final long serialVersionUID = 4632141372373057482L;

/** additional output element (for verbose modes) */
  DBO dbo = new DBO();

  /** print the estimators */
  public static int D_ESTIMATORS         = 1;

  /** print header of converted data set */
  public static int D_CONVDATA           = 2;

  /** print info about all bins */
  public static int D_ALLBINS            = 3;

  /** print picture info about all bins */
  public static int D_ALLBINSPICT        = 4;

  /** analyze bins with their class differences - short output*/
  public static int D_DIFFSHORTABPICT    = 5;

  /** analyze bins with their class differences - long output*/
  public static int D_DIFFAB_WIDEPICT    = 6;

  /** print info about leave bins */
  public static int D_BINS               = 7;

  /** print block picture info about leave bins */
  public static int D_BINSPICT           = 8;

  /** print picture info about bins actually used*/
  public static int D_BINSUSEDPICT       = 9;

  /** print complete converted data set */
  public static int D_CONVDATAALL        = 10;

  /** print header of converted data set */
  public static int D_BINSCUTONLY        = 11;

  /** print text of borders */
  public static int D_BINSRULESTEXT      = 12;

  /** print all bins only the numbers of a and b instances */
  public static int D_BINNUMS            = 13;

  /** print info from all bins not only centres */
  public static int D_ALLBININFO         = 14;

  /** print info from all bins not only centres */
  public static int D_ALLBINSCLUS        = 15;

  /** print info from all bins not only centres */
  public static int D_WIDEPICT           = 16;

  /** print combined cluster pict blocks */
  public static int D_CLUSTERBLOCKS      = 17;
  
  /** analyze bins with their class differences - long output*/
  public static int D_DIFFAB_WIDEPICT_CLUSTERS    = 18;

 /** output the percentage of pos instances in bins */
  public static int D_PERCENTOFBINS      = 25;

  /** flag set if no clustering around centres is wished */
  private boolean m_noClustering = false;

  /** flag set if instances on edges are ignored  */
  private boolean m_noEdges = false;

  /** flag set if instances on edges are ignored  */
  private boolean m_multipleRuns = false;

  /** different choices of splitting methods */
  /** split unsing only normal density */
  private static final int DENSITY       = 1;

  /** split using diversing density of positiv and negativ instances */
  private static final int DIVDENSITY    = 2;

  /** holds the choice of the splitting methods */
  private int m_compareMethod = DENSITY;

  /** the cut methods  */

  /** take the leaves only */
  public static final int CUT_LEAVES_ONLY           = 1;
  /** take leaves and inner nodes, but not the root */
  //public static final int CUT_All_NODES             = 2;
  /** split into both classes, cut then mix cuts and take leaves only */
  public static final int CUT_BOTH_CLASSES_LEAVES   = 3;

  /** the cut method */
  protected int m_cutMethod = CUT_LEAVES_ONLY;

  /** flag if bins should have xor relationship to clusters */
  protected boolean m_XORClusters = false;

  /** the prior probabilities for clusters */
  private double m_priors[];

  /** class index */
  private int m_classIndex = - 1;

  /** class index string (default is 0 which is translated into -1)*/
  private String m_classIndexString = "0";

  /** number of clusters found */
  private int m_numClusters;

  /** The multidimensional binning estimator estimators. */
  protected MultiEstimator m_estimator = new weka.estimators.MultiTUBE();

  /** the centre bins */
  private Vector m_centreBins = null;

  /** the cluster bin lists */
  private Vector [] m_clusterBinList = null;

  /** the centrepoints */
  private Instance [] m_centrePoints = null;

  private boolean [] m_listOfCuttingAtts = null;

  /** the data used */
  private Instances m_data = null;
  
  /** the positive data */
  private Instances m_data_pos = null;

  /** the bins for the density, sometimes made with the positive instances only*/
  protected Vector m_bins = null;

  /** the bins for the density, made with the negative instances only */
  protected Vector m_negbins = null;

  /** the root of the divison tree */
  protected Tree m_tree = null;

  /** difference bins */
  MultiDifference m_diff = null;
  
  /** densities used for wide pict representation */
  double m_maxDensity = Double.NaN;
  double m_maxABDensity = Double.NaN;

  /** globally replace missing values */
  private ReplaceMissingValues m_replaceMissing;

  /** Constructor */
  public MultiTUBEClusterer () {
    // for the verbose (DBO) output
    dbo.initializeRanges(30);
  }

  /**
   * Returns default capabilities of the clusterer.
   *
   * @return      the capabilities of this clusterer
   */
  public Capabilities getCapabilities() {
    Capabilities result = super.getCapabilities();

    // attributes
    result.enable(Capability.NOMINAL_ATTRIBUTES);
    result.enable(Capability.NUMERIC_ATTRIBUTES);
    result.enable(Capability.NOMINAL_CLASS);
    //result.enable(Capability.DATE_ATTRIBUTES);
    result.enable(Capability.MISSING_VALUES);

    // other
    result.setMinimumNumberInstances(0);
    return result;
  }

  /**
   * Calls the estimator to cut the bins
   * @param data the data to be discretized
   * @return vector of 2 with the bins to use and ...?
   */
  public Vector[] cutBins(Instances data) {
    Vector [] binsToUse = new Vector[2];
    binsToUse[0] = null;
    binsToUse[1] = null;
    int numInst = data.numInstances();
    int numAttr = data.numAttributes();
    switch (m_cutMethod) {
    case 1:  
      try {
	// make the bin tree
	((MultiEstimator)m_estimator).addValues(data, data.classIndex(), -1);
	// set the root
	m_tree = ((MultiBinningEstimator)m_estimator).getTree();
	m_bins = ((MultiBinningEstimator)m_estimator).getBins();
	//m_usedAttrList = ((MultiTUBE)m_estimator).getUsedAttrs();
      } catch (Exception ex) {
	ex.printStackTrace(); 
	System.out.println(ex.getMessage());
	throw new IllegalStateException("Error while making bins");          
      }
      if (dbo.dl(D_BINSPICT)) { //
	dbo.dpln("" + MultiBinningUtils.fullBinsToPictBlock(m_bins, true));
      }

      // 
      MultiBinningUtils.refillBins(data, m_bins, true);
      MultiBinningUtils.refillBinsAsTrain(data, m_bins);

      if (dbo.dl(D_DIFFAB_WIDEPICT)) {
	//MultiBinningUtils.refillBins(data, m_bins, true);
	// get max density
	m_maxDensity = MultiBinningUtils.getMaxDensity(m_bins);
	m_maxABDensity = MultiBinningUtils.getMaxABDensity(m_bins);
	dbo.dpln("cutmethod ="+m_cutMethod +
	    MultiBinningUtils.binsToPictStringRow(m_bins, true, true, true, true, true,
	    m_maxDensity, m_maxABDensity, false));
      } else
	MultiBinningUtils.refillBins(data, m_bins, false);

      binsToUse[0] = m_bins;
      break;

    case 3:
      // set the root
      try {

	// find the minimal and the maximal values 
	double [] min = new double[numAttr];
	double [] max = new double[numAttr];
	
	double []minMax = new double[2];
	for (int i = 0; i < numAttr; i++) {
	  if (i != data.classIndex()) {
	    try {
	      EstimatorUtils.getMinMax(data, i, minMax);
	    } catch (Exception ex) {
	      ex.printStackTrace();
	      System.out.println(ex.getMessage());
	    }
	    min[i] = minMax[0];
	    max[i] = minMax[1];
	  }
	}

	// split data first 
	m_data_pos = new Instances(data, 0);
	Instances data_neg = new Instances(data, 0);

	for (int i = 0; i < numInst; i++) {
	  if (data.instance(i).value(data.classIndex()) == 0) {
	    data_neg.add(data.instance(i));
	  } else {
	    m_data_pos.add(data.instance(i));
	  }     
	}
	//DBO.pln("numpos "+data_pos.numInstances()+" numneg "+data_neg.numInstances());
	MultiEstimator est_pos = MultiEstimator.clone(m_estimator);
	MultiEstimator est_neg = MultiEstimator.clone(m_estimator);

	((MultiEstimator)est_pos).addValues(m_data_pos, m_data_pos.classIndex(), min, max);
	Tree tree_pos = ((MultiBinningEstimator)est_pos).getTree();
	Vector pos_bins = ((MultiBinningEstimator)est_pos).getBins();
	//DBO.pln(MultiBinningUtils.binsToString(pos_bins));
	//DBO.pln("positive bins");
	//DBO.pln(" ");

	((MultiEstimator)est_neg).addValues(data_neg, data_neg.classIndex(), min, max);
	Tree tree_neg = ((MultiBinningEstimator)est_neg).getTree();
	Vector neg_bins = ((MultiBinningEstimator)est_neg).getBins();  
	m_negbins = neg_bins;
	//DBO.pln(MultiBinningUtils.binsToString(neg_bins));
	//DBO.pln("negative bins");
	//DBO.pln(" ");

	// make bins from pos and negative bins
	//if (dbo.dl(D_DIFFAB_WIDEPICT)) {
	// m_diff = new MultiDifference(tree_pos, tree_neg, true, (MultiTUBE)est_pos);
	//} else {
	m_diff = new MultiDifference(numInst, tree_pos, tree_neg, false, (MultiTUBE)est_pos,
	    ((MultiTUBE)est_pos).getUsedAttrs(), ((MultiTUBE)est_neg).getUsedAttrs());	          
	//}
	m_estimator = m_diff;
	m_bins = m_diff.getBins();
	//**DBO.pln(MultiBinningUtils.binsToString(m_bins));
	//**DBO.pln("diff bins");
	//**DBO.pln(" ");
	MultiBinningUtils.refillBins(data, m_bins, true);
	MultiBinningUtils.refillBinsAsTrain(data, m_bins);
	if (dbo.dl(D_BINSPICT)) { //
	  dbo.dpln("" + MultiBinningUtils.fullBinsToPictBlock(m_bins, true));
	}
	if (dbo.dl(D_DIFFAB_WIDEPICT)) {
	  // get max density
	  m_maxDensity = MultiBinningUtils.getMaxDensity(m_bins);
	  m_maxABDensity = MultiBinningUtils.getMaxABDensity(m_bins);
	  dbo.dpln("cutmethod ="+m_cutMethod +
	      MultiBinningUtils.binsToPictStringRow(m_bins, true, true, true, true, true,
	      m_maxDensity, m_maxABDensity, false));
	}

	m_listOfCuttingAtts = m_diff.getUsedAttrs();

	//DBO.pln(MultiBinningUtils.diffBinsToString(diff_bins));
	//DBO.pln(MultiBinningUtils.diffBinsToABString(diff_bins, true, false));
	//DBO.pln(MultiBinningUtils.diffBinsToABString(diff_bins, false, true));

      } catch (Exception ex) {
	ex.printStackTrace(); 
	System.out.println(ex.getMessage());
	throw new IllegalStateException("Error while making bins");          
      }
      m_tree = m_diff.getTree();


      binsToUse[0] = m_bins;
      binsToUse[1] = m_negbins;     
      break;
    case 4:
      // set the root
      try {

	// * find the minimal and the maximal values 
	double [] min = new double[numAttr];
	double [] max = new double[numAttr];
	
	double []minMax = new double[2];
	for (int i = 0; i < numAttr; i++) {
	  if (i != data.classIndex()) {
	    try {
	      EstimatorUtils.getMinMax(data, i, minMax);
	    } catch (Exception ex) {
	      ex.printStackTrace();
	      System.out.println(ex.getMessage());
	    }
	    min[i] = minMax[0];
	    max[i] = minMax[1];
	  }
	}

	// * split into pos and neg 
	m_data_pos = new Instances(data, 0);
	Instances data_neg = new Instances(data, 0);
	for (int i = 0; i < numInst; i++) {
	  if (data.instance(i).value(data.classIndex()) == 0) {
	    data_neg.add(data.instance(i));
	  } else {
	    m_data_pos.add(data.instance(i));
	  }     
	}
	
	// * get minimal min and max with neg
	for (int i = 0; i < numAttr; i++) {
	  if (i != data_neg.classIndex()) {
	    try {
	      EstimatorUtils.getMinMax(data_neg, i, minMax);
	    } catch (Exception ex) {
	      ex.printStackTrace();
	      System.out.println(ex.getMessage());
	    }
	    if (minMax[0] > min[i]) min[i] = minMax[0];
	    if (minMax[1] < max[i]) max[i] = minMax[1];
	  }
	}
			
	// * get minimal min and max with pos
	for (int i = 0; i < numAttr; i++) {
	  if (i != m_data_pos.classIndex()) {
	    try {
	      EstimatorUtils.getMinMax(m_data_pos, i, minMax);
	    } catch (Exception ex) {
	      ex.printStackTrace();
	      System.out.println(ex.getMessage());
	    }
	    if (minMax[0] > min[i]) min[i] = minMax[0];
	    if (minMax[1] < max[i]) max[i] = minMax[1];
	  }
	}
			
	//DBO.pln("numpos "+data_pos.numInstances()+" numneg "+data_neg.numInstances());
	
	// * built pos and neg estimator 
	MultiEstimator est_pos = MultiEstimator.clone(m_estimator);
	MultiEstimator est_neg = MultiEstimator.clone(m_estimator);

	((MultiEstimator)est_pos).addValues(m_data_pos, m_data_pos.classIndex(), min, max);
	Tree tree_pos = ((MultiBinningEstimator)est_pos).getTree();
	Vector pos_bins = ((MultiBinningEstimator)est_pos).getBins();
	//DBO.pln(MultiBinningUtils.binsToString(bins));
	//DBO.pln("positive bins");

	((MultiEstimator)est_neg).addValues(data_neg, data_neg.classIndex(), min, max);
	Tree tree_neg = ((MultiBinningEstimator)est_neg).getTree();
	Vector neg_bins = ((MultiBinningEstimator)est_neg).getBins();  
	m_negbins = neg_bins;
	//DBO.pln(MultiBinningUtils.binsToString(bins));
	//DBO.pln("negative bins");

	// == make bins from pos and negative bins
	m_diff = new MultiDifference(numInst, tree_pos, tree_neg, false, (MultiTUBE)est_pos,
	    ((MultiTUBE)est_pos).getUsedAttrs(), ((MultiTUBE)est_neg).getUsedAttrs());	          
	//}
	//if (dbo.dl(D_DIFFAB_WIDEPICT)) {
	// m_diff = new MultiDifference(tree_pos, tree_neg, true, (MultiTUBE)est_pos);
	//} else {
	m_estimator = m_diff;
	m_bins = m_diff.getBins();
	MultiBinningUtils.refillBins(data, m_bins, true);
	MultiBinningUtils.refillBinsAsTrain(data, m_bins);
	if (dbo.dl(D_DIFFAB_WIDEPICT)) {
	  // get max density
	  m_maxDensity = MultiBinningUtils.getMaxDensity(m_bins);
	  m_maxABDensity = MultiBinningUtils.getMaxABDensity(m_bins);
	  dbo.dpln("cutmethod =" + m_cutMethod +
	      MultiBinningUtils.binsToPictStringRow(m_bins, true, true, true, true, true,
	      m_maxDensity, m_maxABDensity, false));
	}
	m_listOfCuttingAtts = m_diff.getUsedAttrs();

	//DBO.pln(MultiBinningUtils.diffBinsToString(diff_bins));
	//DBO.pln(MultiBinningUtils.diffBinsToABString(diff_bins, true, false));
	//DBO.pln(MultiBinningUtils.diffBinsToABString(diff_bins, false, true));

      } catch (Exception ex) {
	ex.printStackTrace(); 
	System.out.println(ex.getMessage());
	throw new IllegalStateException("Error while making bins");          
      }
      m_tree = m_diff.getTree();


      binsToUse[0] = m_bins;
      binsToUse[1] = m_negbins;     
      break;

    default: 
      break;
    }
    // get max density
    if (Double.isNaN(m_maxDensity)) 
      m_maxDensity = MultiBinningUtils.getMaxDensity(binsToUse[0]);

    if (dbo.dl(D_WIDEPICT)) {
      dbo.dpln(MultiBinningUtils.binsToPictStringRow(binsToUse[0], false, true, true, true, true,
	  m_maxDensity, 0.0, false));
    }

    return binsToUse;
  }

  public String binsToPictStringRow() {
    if (Double.isNaN(m_maxDensity))    
      m_maxDensity = MultiBinningUtils.getMaxDensity(m_bins);
    String txt = MultiBinningUtils.binsToPictStringRow(m_bins, false, true, true, true, true,
	m_maxDensity, 0.0, false); 
    return txt;
  }

  public void buildClustererMultiple(Instances data)
  throws Exception {

    MultiEstimator est = getEstimator();
    Instances saveData = new Instances(data);
    setMultipleRuns(false);
    int maxNumBins = ((MultiTUBE)est).getMaxNumBins();
    for (int numBins = 2; numBins <= maxNumBins; numBins++) {
      MultiEstimator workEstimator = MultiEstimator.makeCopy(est);
      ((MultiTUBE)workEstimator).setMaxNumBins(numBins);
      setEstimator(workEstimator);
      buildClusterer(saveData);
      DBO.pln("num bins: " + numBins + " num Clusters found: " + m_numClusters);
    }
    setMultipleRuns(true);
    
  }
  
  /**
   * Generates a clusterer. Has to initialize all fields of the clusterer
   * that are not being set via options.
   *
   * @param workData set of instances serving as training data 
   * @throws Exception if the clusterer has not been 
   * generated successfully
   */
  public void buildClusterer(Instances data)
  throws Exception {

    if (m_multipleRuns) {
      buildClustererMultiple(data);
      return;
    }
    Instances workData = new Instances(data);
    //DBO.pln("buildClusterer-Instances");
    m_data = workData;
    double num = workData.numInstances();

    // can clusterer handle the data?
    getCapabilities().testWithFail(workData);
    m_replaceMissing = new ReplaceMissingValues();
    Instances instances = new Instances(workData);
    instances.setClassIndex(-1);
    m_replaceMissing.setInputFormat(instances);
    workData = weka.filters.Filter.useFilter(instances, m_replaceMissing);
    instances = null;
   
    int classindex = Integer.parseInt(getClassIndexString(workData)) - 1;
    //DBO.pln("classindex "+classindex);
    //DBO.pln("numatts "+ workData.numAttributes());
    setClassIndex(Integer.parseInt(getClassIndexString(workData)) - 1);
    ////data.setClassIndex(-1);
    //m_replaceMissing = new ReplaceMissingValues();
    //Instances instances = new Instances(data);
    //instances.setClassIndex(-1);
    //m_replaceMissing.setInputFormat(instances);
    //data = weka.filters.Filter.useFilter(instances, m_replaceMissing);
    //instances = null;

    ((MultiTUBE)m_estimator).setCompareMethod(m_compareMethod);
    if (m_classIndex > 0) {
      workData.setClassIndex(m_classIndex);
    }

    //((MultiEstimator)m_estimator).addValues(data, data.classIndex(), -1);
    //Vector infoBins = ((MultiBinningEstimator)m_estimator).getBins();
    
    // ******************************************************************************************
    // *** CUT BINS!!!  
    Vector [] infoBins = cutBins(workData);
    Vector bins = infoBins[0];

    if (dbo.dl(D_ALLBININFO)) { // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      
      dbo.dpln("");
      if (dbo.dl(D_BINS)) { //
	dbo.dpln("all bins \n" + MultiBinningUtils.fullBinsToString(bins));
      }
      if (dbo.dl(D_BINSPICT)) { //
	dbo.dpln("All leave bins \n" + MultiBinningUtils.fullBinsToPictBlock(bins, true));
      }
      if (dbo.dl(D_BINSRULESTEXT)) {
	dbo.dpln("All leave bins \n" + MultiBinningUtils.fullBinsToRulesText(bins, workData));
      }
      if (dbo.dl(D_BINNUMS)) {
	dbo.dpln("all bins \n" + MultiBinningUtils.binsToNumString(bins));
      }
      
      dbo.dpln("");
    } // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
      
    
    // *******************************************************************************************
    // find all centres = do clustering
    ((MultiTUBE)m_estimator).findOnlyNonZeroCentreBins(true);
    
    /*if (!m_XORClusters) {
      ((MultiTUBE)m_estimator).findCentreBins(true);
    } else {
      ((MultiTUBE)m_estimator).findXORCentreBins(true);      
    }*/

    // do only binning no clustering
    if (m_noClustering) 
      return;    

    // find centre bins
    m_centreBins = ((MultiTUBE)m_estimator).getCentreBins();
 
    // find bins around and below, down into all valleys
    m_clusterBinList = ((MultiTUBE)m_estimator).getClusterBinList();

     if (dbo.dl(D_DIFFAB_WIDEPICT_CLUSTERS)) { // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
      // get max density
      m_maxDensity = MultiBinningUtils.getMaxDensity(m_bins);
      m_maxABDensity = MultiBinningUtils.getMaxABDensity(m_bins);
      int numCentres = m_centreBins.size();
      for (int i = 0; i < numCentres; i++) {
	dbo.pln("Cluster: "+i);
	Vector centre = new Vector();
	centre.add((MultiBin)m_centreBins.elementAt(i));
	dbo.dpln(MultiBinningUtils.binsToPictStringRow(centre, true, true, true, true, true,
	    m_maxDensity, m_maxABDensity, false));
	dbo.pln("Cluster Bin List: "+i);
	dbo.dpln(MultiBinningUtils.binsToPictStringRow(m_clusterBinList[i], true, true, true, true, true,
	    m_maxDensity, m_maxABDensity, false));
      }
    } // -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
    
   //m_centreBins = (MultiBin []) centres.toArray();
    m_numClusters = m_centreBins.size();
    m_centrePoints = new Instance[m_numClusters];
    for (int i = 0; i < m_numClusters; i++) {
      MultiBin bin = (MultiBin)m_centreBins.elementAt(i);
      m_centrePoints[i] = bin.getCentrePoint(false, workData);
    }

    if (dbo.dl(D_CLUSTERBLOCKS)) {
      dbo.dpln("****bin list lengths ****************");
      for (int i = 0; i < m_numClusters; i++) {     
	dbo.dpln(" "+i+" : "+m_clusterBinList[i].size());
      }
      dbo.dpln("");
    }
    if (dbo.dl(D_CLUSTERBLOCKS)) {
      dbo.dpln("****combine cluster bins to blocks ****************");
      for (int i = 0; i < m_numClusters; i++) {     
	Vector blockBins = getBlockBins(m_clusterBinList[i]);

      }
      dbo.dpln("");
    }

  }

  /**
   * Generates a clusterer. Has to initialize all fields of the clusterer
   * that are not being set via options.
   *
   * @param data set of instances serving as training data 
   * @throws Exception if the clusterer has not been 
   * generated successfully
   */
  public void buildClusterer(Instances data, int numBins, double minPercent)
  throws Exception {
    DBO.pln("buildClusterer-Instances,int,double");
    m_data = data;

    // can clusterer handle the data?
    getCapabilities().testWithFail(data);
    
    setClassIndex(Integer.parseInt(getClassIndexString(data)) - 1);

    ((MultiTUBE)m_estimator).setCompareMethod(m_compareMethod);
    if (m_classIndex > 0) {
      data.setClassIndex(m_classIndex);
    }

    // make the cutting here *******************
    Vector [] infoBins = cutBins(data);
    Vector bins = infoBins[0];

    if (dbo.dl(D_ALLBININFO)) {
      dbo.dpln("");
      if (dbo.dl(D_BINS)) { //
	dbo.dpln("all bins \n" + MultiBinningUtils.fullBinsToString(bins));
      }
      if (dbo.dl(D_BINSPICT)) { //
	dbo.dpln("All leave bins \n" + MultiBinningUtils.fullBinsToPictBlock(bins, true));
      }
      if (dbo.dl(D_BINSRULESTEXT)) {
	dbo.dpln("All leave bins \n" + MultiBinningUtils.fullBinsToRulesText(bins, data));
      }
      if (dbo.dl(D_BINNUMS)) {
	dbo.dpln("all bins \n" + MultiBinningUtils.binsToNumString(bins));
      }
      dbo.dpln("");
    }

    // find num densest bins (put them to centres
    ((MultiTUBE)m_estimator).findDensestBins(numBins, minPercent);

    // find centre bins
    m_centreBins = ((MultiTUBE)m_estimator).getCentreBins();
    if (dbo.dl(D_DIFFAB_WIDEPICT)) {
      // get max density
      m_maxDensity = MultiBinningUtils.getMaxDensity(m_bins);
      m_maxABDensity = MultiBinningUtils.getMaxABDensity(m_bins);
      int numCentres = m_centreBins.size();
      for (int i = 0; i < numCentres; i++) {
	dbo.pln("Densest Bin: "+i);
	Vector centre = new Vector();
	centre.add((MultiBin)m_centreBins.elementAt(i));
	dbo.dpln(MultiBinningUtils.binsToPictStringRow(centre, true, true, true, true, true,
	    m_maxDensity, m_maxABDensity, false));
      }
    }
  }

  private Vector getBlockBins(Vector binlist) {
    BinPath[] pathsList = MultiBinningUtils.sortBinsByPathString(binlist);
    Vector blocks = null;
    boolean nopairfound = true;
    int numPaths = pathsList.length;
    do {
      for (int i = 0; i < pathsList.length - 1; ) {
	int len = pathsList[i].pathString.length();
	if ((len == pathsList[i + 1].pathString.length()) &&
	    (pathsList[i].pathString.substring(0, len - 2) 
		== pathsList[i].pathString.substring(0, len - 2))) {
	  //MultiBin parent = (MultiBin)binlist.elementAt(i).getParentBin();  
	  // get Parent bin
	  // delete both bins and add parent bin
	  // change pathlist

	  i = i + 2;
	  nopairfound = false;
	} else {
	  i = i + 1;
	}
      }

    } while (!nopairfound);

    return blocks;
  }

  public boolean [] listOfCuttingAtts() {
    return m_listOfCuttingAtts;
  }

  /**
   * Classifies a given instance.
   *
   * @param instance the instance to be assigned to a cluster
   * @return the number of the assigned cluster as an interger
   * if the class is enumerated, otherwise the predicted value
   * @throws Exception if instance could not be classified
   * successfully
   */
  public int clusterInstance(Instance instance) throws Exception {

    m_replaceMissing.input(instance);
    instance = m_replaceMissing.output();
    int clNum = -1;
    for (int i = 0; i < m_numClusters && clNum < 0; i++) {

      int numBins = m_clusterBinList[i].size();
      for (int j = 0; j < numBins && clNum < 0; j++) {
	MultiBin bin = (MultiBin)m_clusterBinList[i].elementAt(j);
	if (bin.fitsInto(instance)) {
	  clNum = i;
	}
      }
    }
    return clNum;
  }

  /**
   * Computes the log of the conditional density (per cluster) for a given instance.
   * 
   * @param inst the instance to compute the density for
   * @return an array containing the estimated densities
   * @throws Exception if the density could not be computed
   * successfully
   *
  public double[] logDensityPerClusterForInstance(Instance inst) throws Exception {

    int i, j;
    double logprob;
    double[] wghts = new double[m_numClusters];
    /*  
    m_replaceMissing.input(inst);
    inst = m_replaceMissing.output();

    for (i = 0; i < m_numClusters; i++) {
      //      System.err.println("Cluster : "+i);
      logprob = 0.0;

      for (j = 0; j < m_num_attribs; j++) {
	if (!inst.isMissing(j)) {
	  if (inst.attribute(j).isNominal()) {
	    logprob += Math.log(m_baglessModel[i][j].getProbability(inst.value(j)));
	  }
	  else { // numeric attribute
	    logprob += logNormalDens(inst.value(j), 
				     m_modelNormal[i][j][0], 
				     m_modelNormal[i][j][1]);
	    /*	    System.err.println(logNormalDens(inst.value(j), 
				     m_modelNormal[i][j][0], 
				     m_modelNormal[i][j][1]) + " "); **
	  }
	}
      }
      //      System.err.println("");

      wghts[i] = logprob;
    }
     
    return  wghts;
  }*/

  /**
   * Returns the cluster priors.
   * 
   * @return the cluster priors
   *
  public double[] clusterPriors() {

    double[] n = new double[m_priors.length];

    System.arraycopy(m_priors, 0, n, 0, n.length);
    return n;
  } */

  /**
   * Returns the number of clusters.
   *
   * @return the number of clusters generated for a training dataset.
   * @throws Exception if number of clusters could not be returned
   * successfully
   */
  public int numberOfClusters ()
  throws Exception {
    if (m_numClusters == -1) {
      throw  new Exception("Haven't generated any clusters!");
    }
    return  m_numClusters;
  }
  
  public boolean[] getListOfCuttingAtts() {
    return m_listOfCuttingAtts;
  }

  public Vector getBins() {
    return m_bins;
  }

  public Vector getCentreBins() {
    return m_centreBins;
  }

  public Vector[] getClusterBinList() {
    return m_clusterBinList;
  }

  public Instance[] getCentrePoints() {
    return m_centrePoints;
  }

  public Vector getCentrePoints(boolean debug, Vector bins) {
    //correct one
    int numBins = bins.size();
    Vector centrePoints = new Vector();
    for (int i = 0; i < numBins; i++) {
      MultiBin bin = (MultiBin)bins.elementAt(i);
      Instance newPoint = bin.getCentrePoint(debug, m_data_pos);
      centrePoints.add(newPoint);
    }
    return centrePoints;
  }

  public Vector getCentrePoints(boolean debug, Vector bins, Random random) {
    //correct one
    int numBins = bins.size();
    Vector centrePoints = new Vector();
    for (int i = 0; i < numBins; i++) {
      MultiBin bin = (MultiBin)bins.elementAt(i);
      Instance newPoint = bin.getCentrePoint(debug, m_data_pos, random);
      centrePoints.add(newPoint);
    }
    return centrePoints;
  }

 public static Instance[] getCentrePoints(boolean debug, Instances train, MultiBin [] centreBins) {
    int numBins = centreBins.length;
    Instance [] centrePoints = new Instance[numBins];
    for (int i = 0; i < numBins; i++) {
      centrePoints[i] = centreBins[i].getCentrePoint(debug, train);
    }
    return centrePoints;
  }

  public static Instance[] getCentrePointsReal(boolean debug, Instances train, MultiBin [] centreBins) {
    int numBins = centreBins.length;
    Instance [] centrePoints = new Instance[numBins];
    for (int i = 0; i < numBins; i++) {
      centrePoints[i] = centreBins[i].getCentrePointReal(debug, train);
    }
    return centrePoints;
  }

  /** 
   * Sets if bins should have XOR relationship to clusters
   * @param flag the new flag
   */
  public void setXORClusters(boolean flag) {
    m_XORClusters = flag;
  }

  /** 
   * Sets whether illegal cuts are dissallowed
   * @return true if illegal cuts are set to be disallowed
   */
  public boolean getXORClusters() {
    return m_XORClusters;
  }

  /** 
   * Sets which kind of compare method sshould be used
   * @param num new compare method
   */
  public void setCompareMethod(int num) {
    m_compareMethod = num;
  }

  /** 
   * Sets whether illegal cuts are dissallowed
   * @return true if illegal cuts are set to be disallowed
   */
  public int getCompareMethod() {
    return m_compareMethod;
  }

  public void setNoClustering(boolean flag) {
    m_noClustering = flag;
  }

  public boolean getNoClustering() {
    return m_noClustering;
  }

  public void setNoEdges(boolean flag) {
    m_noEdges = flag;
  }

  public boolean getNoEdges() {
    return m_noEdges;
  }

  /**
   * 
   * @param flag
   */
  public void setMultipleRuns(boolean flag) {
    m_multipleRuns = flag;
  }
  
  /**
   * 
   * @return
   */
  public boolean getMultipleRuns() {
    return m_multipleRuns;
  }

  /**
   * Sets the estimator
   *
   * @param estimator the estimator with all options set.
   */
  public void setEstimator(MultiEstimator estimator) {

    m_estimator = (MultiEstimator)estimator;
  }

  /**
   * Gets the estimator used.
   *
   * @return the estimator
   */
  public MultiEstimator getEstimator() {

    return m_estimator;
  }

  /**
   * Gets the estimator specification string.
   *
   * @return the estimator string.
   */
  protected String getEstimatorSpec() {

    MultiEstimator e = getEstimator();
    if (e == null) return "";
    if (e instanceof OptionHandler) {
      return e.getClass().getName() + " "
      + Utils.joinOptions(((OptionHandler) e).getOptions());
    }
    return e.getClass().getName();
  }

  /**
   * Switches the outputs on that are requested from the option V
   * if list is empty switches on the verbose mode only
   * 
   * @param list list of integers, all are used for an output type
   */
  public void setVerboseLevels(String list) { 
    dbo.setOutputTypes(list);
  }

  /**
   * Gets the current output type selection
   *
   * @return a string containing a comma separated list of ranges
   */
  public String getVerboseLevels() {
    return dbo.getOutputTypes();
  }

  /**
   * Sets the class index. The class attribute is ignored for the clustering.
   * 
   * @param list list of integers, all are used for an output type
   */
  private void setClassIndex(int num) { 
    m_classIndex = num;
    m_classIndexString = "" + (num + 1);
  }

  /**
   * Sets the string that represents the classindex
   * @param st the string that represents the class index
   */
  public void setClassIndexString(String st) { 
    m_classIndexString = st;
    if (st.compareTo("last") == 0) {
      m_classIndexString = st;
    } else {
      if (st.compareTo("first") == 0) {
	m_classIndexString = "1";
      } else {
	try {
	  int c = Integer.parseInt(st);
	  m_classIndexString = st;
	} catch (Exception ex) {
	  
	}
      }
    }
  }

  /**
   * Returns the data string. Transforms the string 'last' to the last index in the 
   * data set.
   * @return a string containing a comma separated list of ranges
   */
  public String getClassIndexString() {
    return getClassIndexString(null);
  }

  /**
   * Returns the data string. Transforms the string 'last' to the last index in the 
   * data set.
   * @return a string containing a comma separated list of ranges
   */
  private String getClassIndexString(Instances data) {
    if (m_classIndexString.compareTo("last") == 0)
      if (data != null) {
	m_classIndexString = "" + data.numAttributes();
      }
    return m_classIndexString;
  }

  /** 
   * Sets which way the cut should be performed
   * @param num the cut method index
   */
  public void setCutMethod(int num) {
    m_cutMethod = num;
  }

  /** 
   * Gets which way the cut should be performed 
   * @return the cut method
   */
  public int getCutMethod() {
    return m_cutMethod;
  }
  
  public double getMaxDensity() {
    return m_maxDensity;
  }

  public double getMaxABDensity() {
    return m_maxABDensity;
  }

 private void resetOptions() {
    m_classIndex = -1;
    m_compareMethod = DENSITY;
    m_cutMethod = CUT_LEAVES_ONLY;
    m_classIndexString = "0";
    m_estimator = new weka.estimators.MultiTUBE();
    m_noClustering = false;
    m_noEdges = false;
    //m_data = null;
    //m_bins = null;
    //m_negbins = null;
    //m_tree = null;
    //m_diff = null;
  }

  /**
   * Returns an enumeration describing the available options
   * 
   * @return an enumeration of all the available options
   */
  public Enumeration listOptions() {
    Vector newVector = new Vector(7);
    //Enumeration enu = super.listOptions();
    //while (enu.hasMoreElements()) {
    //  newVector.addElement(enu.nextElement());
    //}
    return newVector.elements();
  }

  /**
   * Gets the current settings of the classifier.
   *
   * @return an array of strings suitable for passing to setOptions
   */
  public String [] getOptions() {
    Vector<String>        result;
    String[]      options;
    //DBO.pln("getOptions ");
    result = new Vector<String>( );
    //options = super.getOptions();
    //for (int i = 0; i < options.length; i++)
    //  result.add(options[i]);

    // estimator
    result.add("-E");
    result.add("" + getEstimatorSpec());

    //  classindex
    result.add("-L");
    result.add("" + getClassIndexString(null));
    //DBO.pln("getOptions " + getClassIndexString(null));
    
    // verbose settings
    String verboseLevels = getVerboseLevels();
    if (verboseLevels.length() > 0) {
      result.add("-V");
      result.add("" + verboseLevels);
    }

    // cut method  
    result.add("-C");
    result.add("" + getCutMethod());
    
    // compare method
    result.add("-Y");
    result.add("" + getCompareMethod());
 
    if (getXORClusters()) 
      result.add("-X");

    if (getNoClustering()) 
      result.add("-O");

    if (getNoEdges()) 
      result.add("-G");

    options = super.getOptions();
    for (int i = 0; i < options.length; i++)
      result.add(options[i]);
    return (String[]) result.toArray(new String[result.size()]);
  }

  /**
   * Parses a given list of options.
   * 
   * @param options
   *          the list of options as an array of strings
   * @throws Exception
   *           if an option is not supported
   */
  public void setOptions(String[] options) throws Exception {
    resetOptions();
    super.setOptions(options);

    // set multidmensional binning estimator and it options
    String [] estSpec = null;
    String estName = "weka.estimators.MultiTUBE";
    String estString = Utils.getOption('E', options);
    if (estString.length() != 0) {
      estSpec = Utils.splitOptions(estString);
      if (estSpec.length == 0) {
	throw new IllegalArgumentException("Invalid estimator specification string");
      }
      estName = estSpec[0];
      estSpec[0] = "";

      setEstimator((MultiEstimator) Utils.forName(MultiEstimator.class, estName, estSpec));
    }

    // set cut method  
    String cutMethod = Utils.getOption('C', options);
    if (cutMethod.length() != 0) {
      setCutMethod(Integer.parseInt(cutMethod));
    }

    // set XOR cluster
    setXORClusters(Utils.getFlag('X', options));

    // set if clustering should not be done
    setNoClustering(Utils.getFlag('O', options));

    // set if edges should be ignored
    setNoEdges(Utils.getFlag('G', options));
    
//  set if multiple runs should be done
    setMultipleRuns(Utils.getFlag('M', options));
    
    // set compare method
    String comparemethod = Utils.getOption('Y', options);  
    if (comparemethod.length() != 0) {
      setCompareMethod(Integer.parseInt(comparemethod));
    } 

    // output info data 
    String outputRange = Utils.getOption('V', options);
    setVerboseLevels(outputRange);

    // set class value
    String cl = Utils.getOption('L', options);  
    if (cl.length() != 0) {     
      setClassIndexString(cl);
    } 
    if ((m_compareMethod == DIVDENSITY && m_classIndexString.compareTo("0") == 0) 
	|| (m_cutMethod == CUT_BOTH_CLASSES_LEAVES && m_classIndexString.compareTo("0") == 0)){ 
      throw new IllegalArgumentException("Class index (option L) must be set for "+
      "diverse density comparing");
    }
  }

  /**
   * Outputs the generated clusters into a string.
   * 
   * @return the clusterer in string representation
   */
  public String toString () {
    if (m_centreBins == null) {
      return "No clusterer built yet!";
    }
    StringBuffer text = new StringBuffer();

    text.append("MultiTUBEClusterer");
    String what = m_estimator.toString();
    text.append("\n==\n\nEstimator used: "+m_estimator.toString());
    text.append("\nNumber of clusters: " + m_numClusters + "\n");

    for (int j = 0; j < m_numClusters; j++) {
      MultiBin bin = (MultiBin)m_centreBins.elementAt(j);
      //text.append("\nCluster: " + j + " Prior probability: " 
      //+ Utils.doubleToString(m_priors[j], 4) + "\n\n");
      text.append("\nCluster: " + j + " \n"
	  + "Centre:" + m_centrePoints[j] + "\n");
      text.append(bin.toNiceString()+ "\n");

      //if (dbo.dl(D_BINS)) { //
      text.append("fullbintostring" + bin.fullBinToString() + "\n");
      //}
      if (dbo.dl(D_BINSPICT)) { //
	text.append("" + bin.fullBinToPictBlock(true) + "\n");
	if (dbo.dl(D_ALLBINSCLUS)) {
	  int numBins = m_clusterBinList[j].size();
	  text.append("Number of bins in cluster: "+numBins);
	  for (int k = 0; k < numBins; k++) {
	    MultiBin clusterBin = (MultiBin)m_clusterBinList[j].elementAt(k);
	    text.append(clusterBin.fullBinToPictBlock(true)+ "\n");
	    text.append(clusterBin.toNiceString()+ "\n");
	  }
	}

      }
      if (dbo.dl(D_BINSRULESTEXT)) {
	text.append(bin.fullBinToRulesText(m_data)+ "\n");
      }
      if (dbo.dl(D_BINNUMS)) {
	text.append(bin.toNumString()+ "\n");
      }

      //text.append( m_centreBins[j].toString());
    }

    return  text.toString();
  }

  /**
   * Returns a string describing this clusterer
   * @return a description of the evaluator suitable for
   * displaying in the explorer/experimenter gui
   */
  public String globalInfo() {
    return
    "Clustering the bins made by MultiTUBE.\n\n";
  }

  public static void tidyupCentreList(boolean debug, Vector centreBins, Vector centrePoints) {
    int numCentres = centreBins.size();
    int numPoints = centrePoints.size();
    if (debug)
      DBO.pln("Num of centres before tidy up " + numCentres);

    int index = 0;
    for (int i = 0; i < numCentres; i++) {
      MultiBin centreBin = (MultiBin)centreBins.elementAt(index);
      if (centreBin.getNumB_Inst() <= 0.0) {
	centreBins.remove(index);
	if (centrePoints != null && numPoints > index) centrePoints.remove(index);
      } else index++;
    }  
    if (debug)
      DBO.pln("Num of centres after tidy up " + centreBins.size());
  }

  /**
   * Delete the bins in the bin list that have less than minPercent pos instances
   * But the first bin (index 0) which is the centre bin is kept anyway
   * @param debug gives output about percentage of positive instances in bin
   * @param minPercent the minimal percentage allowed for non centre bins
   * @param centreBins vector of centre bins
   * @param array of clusterbinlist vectors
   */
  public static void tidyupBinLists(boolean debug, double minPercent, Vector centreBins,
      Vector [] clusterBinList) {

    int numCentres = centreBins.size();
    int [] numPosInstInCluster = new int[numCentres];

    /** reduce the clusterBinLists to the bins with not less than minPercent pos 
     * or just the centre */
    for (int i = 0; i < numCentres; i++){
      MultiBin centreBin = (MultiBin)centreBins.elementAt(i);
      // count number of inst in cluster
      numPosInstInCluster[i] = 0;

      // make new list of bins for the cluster with at least the centre
      Vector bins = new Vector();
      bins.add(centreBin);
      numPosInstInCluster[i] += centreBin.getNumB_Inst();
      if (debug) {
	// analyze centre bin
	double numNeg = centreBin.getNumInst(); 
	double numPos = centreBin.getNumB_Inst();
	double percent = MultiBinningUtils.percent(numNeg + numPos, numPos);
	if (debug)
	  DBO.pln("Centrebin has "+percent+
	      " %  instances; = "+numPos+" centre always added");	
      }
      
      // start from index 1, first is centre bin
      if (debug)
	DBO.pln("*** cluster: " + i + " starts with "
	    + clusterBinList[i].size() + " bin(s)");
      for (int j = 1; j < clusterBinList[i].size(); j++) {

	MultiBin bin = (MultiBin)clusterBinList[i].elementAt(j);
	double numNeg = bin.getNumInst(); 
	double numPos = bin.getNumB_Inst();
	double percent = MultiBinningUtils.percent(numNeg + numPos, numPos);
	if (debug)
	  DBO.p("Bin "+j+" has "+percent+
	      " %  instances; = "+numPos);
	if (percent >= minPercent) {
	  bins.add(bin);
	  numPosInstInCluster[i] += bin.getNumB_Inst();
	  if (debug) { DBO.pln(" * added *"); }
	} else { if (debug) { DBO.pln(" * NOT added *"); } }
      }

      clusterBinList[i] = bins;
      if (debug)
	DBO.pln("*** cluster: "+i+" has after tidy up "+bins.size()+" bin(s)");
      if (debug)
	DBO.pln("    instances: "+numPosInstInCluster[i]);
    }   
  }

  public static Vector tidyupBinVector(boolean debug, Vector bins, double minPercent) {

    Vector tidyBins = new Vector();
    int numBins = bins.size();

    for (int i = 0; i < numBins; i++){

      MultiBin bin = (MultiBin)bins.elementAt(i);
      double numNeg = bin.getNumInst(); 
      double numPos = bin.getNumB_Inst();
      double percent = MultiBinningUtils.percent(numNeg + numPos, numPos);
      if (debug)
	DBO.pln("percent of pos in bin " + i + " is " + percent +
	    " = " + numPos + " positiv instances");
      if (percent >= minPercent) {
	tidyBins.add(bin);
      }
    }

    return tidyBins;
  }

  /**
   * @param args
   */
  public static void main(String[] args) {
    runClusterer(new MultiTUBEClusterer(), args);  
  }

  /**
   * Returns the revision string.
   * 
   * @return		the revision
   */
  public String getRevision() {
    return RevisionUtils.extract("$Revision: 1.00 $");
  }
}
